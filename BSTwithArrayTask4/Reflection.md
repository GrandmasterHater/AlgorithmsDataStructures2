# Задание 2

    В классической рекурсивной реализации для поиска нужного узла мы на каждом шаге рекурсии сравниваем значение ключа текущего узла с заданной парой чисел - если оба значения меньше текущего ключа, то идём в левое поддерево, если оба значения больше, то в правое. Если текущий ключ находится между значениями или же равен какому-то из них, то мы нашли наименьшего общего предка. 
    В реализации с массивом появляется преимущество когда известны индексы узлов для которых ищется LCA. Тогда начиная с индексов узлов пошагово идём вверх и на каждом шаге поднимаем тот узел, который глубже в дереве. Как только индексы совпали LCA найден. Индексы рассчитываются по формуле получения родителя в дереве `(index - 1) / 2`, не требуется делать переход по ссылкам узлов.
    
    Временные сложности алгоритмов совпадают O(h) т.к. в худшем случае нам нужно пройти по всем уровням дерева прежде чем найти нужный узел. Пространственная сложность рекурсивного алгоритма O(h) в случае если не поддерживается оптимизация элиминации хвостовой рекурсии поскольку для каждого узла будет задействован отдельный стековый кадр. Для циклического алгоритма пространственная сложность всегда O(1).


# Задание 3
 
    Здесь возможны 2 варианта. Первый основан на том что в массиве узлы уже выстроены по уровням, т.е. можно линейно пройти по массиву исключая null значения и получить список узлов соответствующий обходу в ширину. Такой способ будет плохо работать на глубоких и узких деревьях т.к. большинство узлов в них будут null. Логика такого варианта будет наиболее проста - в цикле идём по массиву, если `Tree[i].HasValue` даёт true, то узел добавляется в результирующий список.
    Второй вариант основан на том что мы используем тот же принцип обхода, но вычисляем индексы, тогда не будет лишних проходов по пустым (null) узлам. Но в таком случае придётся ввести дополнительную очередь для хранения узлов следующего уровня, что даёт дополнительную пространственную сложность O(w) где w - ширина дерева.
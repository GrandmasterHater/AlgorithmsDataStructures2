# Задание 2

   Временная сложность как при поиске как в классическом дереве, так и в дереве представленном в виде массива одинакова и составляет O(log n).
   С точки зрения вычислений работа с массивом может быть легче - не нужно ходить по ссылкам, индексы массива вычисляются, а данные данные в памяти располагаются упорядоченно. 
   Для массива в процессе вычислений может требоваться меньше времени, поскольку кэш процессора используется эффективнее - меньше перекладываний данных из оперативной памяти в кэш процессора. 

# Задание 3

   Поскольку в условиях задания сказано, что массив не может содержать пустые места, то сделал вывод, что после удаления 
   размер массива должен уменьшиться на 1. Если при этом количество узлов в дереве станет чётным, то у одного из узлов 
   дерева будет только один дочерний узел. При этом, чтобы результирующий массив не имел пустых мест в дереве с чётным 
   количеством узлов нужно, чтобы этот отсутствующий узел был последним в массиве, тогда результирующий массив будет 
   короче исходного на 1 и нужный ключ будет удалён. При этом, тогда требуется каждый раз перестраивать дерево, чтобы 
   оно оставалось сбалансированным и выполнялось озвученное выше условие. 

   Алгоритм следующий - за O(log n) времени находим индекс удаляемого узла. Затем, чтобы исключить значение по нужному 
   индексу, перемещаем его в конец исходного массива за O(1) времени. После этого приступаем к генерации перестроенного 
   дерева - сортируем по возрастанию значения в исходном массиве начина с 0 индекса по `newLength - 1` индекс за 
   O(n log n) времени (сортируем все значения кроме последнего, которое удаляем). После этого используем рекурсивный 
   метод генерации сбалансированного дерева за O(n) времени. Таким образом без лишних аллокаций получаем сбалансированное 
   дерево без указанного ключа за O(n log n) времени. 
   
   Можно улучшить временную сложность заменив сортировку in-order обходом добившись O(n) временной сложности алгоритма удаления узла, но тогда появится дополнительная аллокация массива.

# Задание 4

   Двоичное дерево не требует сортировки т.к. оно хранится в уже отсортированном виде.
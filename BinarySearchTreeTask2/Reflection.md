# Задача 1
    Для решения применяем рекурсию. Публичная функция принимает в качестве параметров два дерева. Внутри публичной функции происходит вызов рекурсивной функции которой передаются корни обоих деревьев. На каждом шаге в рекурсивной функции сравниваются значения текущих узлов - если оба null, то мы дошли до конца дерева и все предыдущие узлы совпадают, возвращаем true. Если один из узлов или оба не равны null то, вызываем функцию сравнения узлов которая проверяет, что оба узла не null и их ключ, и значение совпадают. В случае совпадения узлов рекурсивно вызываем сравнения узлов левой и правой дочерних ветвей. После получения результатов от обеих ветвей производим между ними операцию логического `И` и возвращаем результат. 

    Временная сложность O(n) (где n - количество узлов в дереве) поскольку в худшем случае нужно сравнить каждый из узлов дерева. Пространственная сложность будет равна O(h) (где h - глубина/высота дерева) поскольку тут для каждого рекурсивного вызова будет задействован новый стековый кадр.


# Задача 2
    Для решения применяем рекурсию и добавляем новый тип данных - класс `TreePath`, который представляет из себя наследника класса List и расширяет его публичным свойством `Length` и публичным методом `DeepCopy`. `Length` - представляет длину пути рассчитываемую как `количество узлов - 1`, а также учитывает случай когда на пути нет узлов (в таком случае длина равна 0). Метод DeepCopy создаёт полную копию текущего пути.

    Публичная функция принимает в качестве параметров дерево и искомую длину пути до листа. В публичной прежде чем сделать рекурсивный вызов проверяем его необходимость - убеждаемся, что корневой узел Root не null и не лист. Если условие верно, то делаем вызов рекурсивной функции, которая находит все пути до всех листьев. Функция принимает узел, с которого хотим начать, объект пути `TreePath`, в который записываем путь и результаты всего прохода. Логика рекурсивной функции - добавляем переданный узел в объект `TreePath` (поскольку сам метод гарантирует, что рекурсивных вызовов с node == null не будет, то можно node на null не проверять). Далее проверяем - если текущий узел это лист, то мы дошли до конца пути, значит сохраняем результат и выходим. Если узел это не лист, то далее проверяем есть ли ветвление пути в этом узле (ветвление пути означает, что есть еще один маршрут). Если есть ветвление создаём копию текущего маршрута и в левую ветвь передаём оригинальный маршрут, а в правый его полную копию как новый маршрут. После определения путей запускаем рекурсивные вызовы для левого и правого дочерних узлов при их наличии (если они не null). После завершения рекурсивного поиска всех путей при помощи `Linq` выбираем те, что соответствуют требованию length. 

    Здесь можно было бы избежать лишних аллокаций на Linq - например в цикле пройтись по результатам и удалить все записи, не соответствующие требованию по Length. Это бы позволило избавиться от лишнего копирования листа в `.ToList()` вызове. Также можно было бы сменить возвращаемый тип на IEnumerable<TreePath<T>> - в таком случае можно было бы по прежнему воспользоваться удобством и лаконичностью `Linq` и при этом обойтись без `.ToList()` пожертвовав только скоростью перебора листа. ТАкже можно было сделать рекурсивный метод специализированным и учитывать длину в нём, однако в таком случае его нельзя было бы переиспользовать в следующем задании.

    Временная сложность O(n) поскольку нам всегда нужно пройтись по всем узлам дерева. Пространственная сложность O(n * h) где n - количество путей, а h - глубина стека или же количество узлов в пути. 


# Задача 3
    Решение этой задачи достаточно похоже на решение предыдущей, поэтому для этих 2 решений был выделен общий рекурсивный метод поиска всех путей. Отличие состоит в том, что после поиска всех путей мы дополнительно определяем сумму значений узлов для каждого из путей и выбираем те пути, которые соответствуют максимальному значению суммы. 

    При необходимости можно уменьшить количество аллокаций, отказавшись от `.ToList()` и избыточного применения `Linq`. Также возможен один проход с сохранением максимальной суммы "на лету", что сократит количество проходов по данным, но повлечёт специализацию метода поиска путей.

    Временная и пространственная сложности аналогичны тем, что в задании 2.


# Задача 4
    Решение этой задачи также использует рекурсию. Для проверки симметрии используем подход когда мы одновременно идём по левой и правой ветвям начиная от корневого узла. Если одновременно оба узла равны `null`, то завершаем рекурсивный вызов c результатом `true`. Если же, оба узла не `null` делаем рекурсивные вызовы в дочерним узлам для левой и правой ветви, а затем логически объединяем результаты рекурсивных вызовов. Если же какой-то из узлов оказался `null`, то результатом метода будет `false`
   
   Временная сложность O(n), поскольку в худшем случае надо обойти каждый узел. Пространственная сложность O(h), где h высота стека вызовов.    
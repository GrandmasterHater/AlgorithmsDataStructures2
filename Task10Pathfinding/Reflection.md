# Задание 1
 
   Применяем, согласно заданию, алгоритм DFS для определения связности графа. Для того чтобы понять является ли граф 
связным, нужно из любой вершины графа запустить алгоритм DFS обхода и после обхода проверить, что были посещены все вершины.
   Рекурсивный метод выполняет следующие шаги:
   1) Помечаем вершину как посещенную.
   2) Увеличиваем количество посещенных вершин на 1.
   3) В цикле проходимся по всем вершинам. Если между вершинами есть связь и вершина не посещена, запускаем рекурсивный 
обход начиная со связанной вершины.
   4) Возвращаем количество посещенных вершин.
   
   В итоге получим количество вершин которые были посещены. Если это количество равно количеству вершин в графе, то граф 
   связный.
   
   Временная сложность алгоритма квадратичная O(n^2), поскольку в худшем случае надо обойти каждую вершину и проверить все смежные.
   Пространственная сложность равна глубине стека вызова, по сути количеству вершин графа.

# Задание 2

   Для решения этой задаче также использую рекурсию. Для того чтобы найти длину самого длинного простого пути, нужно для 
каждой вершины запустить рекурсивный метод подсчёта длинны пути из этого узла.
   Рекурсивный метод выполняет следующие шаги:
   1) Помечаем вершину как посещенную.
   2) проходим по всем вершинам. Если между вершинами есть связь и вершина не посещена, запускаем рекурсивный 
обход начиная со связанной вершины. Если длина пути, полученная в результате вызова рекурсивного метода больше чем текущая,
то сохраняем её. Так проходим по каждой непосещенной вершине и выбираем среди всех путей наиболее длинный.
   3) Как только прошли по всем смежным вершинам, то снимаем отметку посещённости, чтобы вершина могла участвовать в 
других путях при дальнейшем поиске. 
   4) Возвращаем длину самого длинного пути. 

   Поскольку в самом худшем случае нужно для каждой вершины выполнить циклы обхода по всем остальным, то сложность алгоритма 
   будет факториальная O(n!) (нужно перебирать все возможные пути). Пространственная сложность O(n), поскольку в худшем 
   случае все вершины попадут в хэшсет посещенных вершин.
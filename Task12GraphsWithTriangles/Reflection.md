# Задание 1
   
   Есть несколько вариантов решений задачи. Первый вариант подразумевает сбор всех возможных треугольников и затем деление 
   на 3 полученного числа. Этот вариант может сработать только для неориентированного графа. Второй вариант подразумевает 
   использование множества (HashSet в C#) которое используется для хранения уже обнаруженных треугольников. 
   
   Поскольку второй вариант более универсален решил воспользоваться им. В множестве треугольник хранится в виде строки,
   полученной из упорядоченного массива вершин треугольников. Решение состоит из следующих основных действий:
   1. Запускаем цикл по всем вершинам графа.
   2. В цикле для каждого узла запускаем алгоритм поиска треугольников связанных с этим узлом.
   3. После прохождения цикла возвращаем количество найденных уникальных треугольников которые находятся в множестве.

   Алгоритм поиска треугольников связанных с узлом состоит из следующих основных действий:
   1. Составление списка смежных вершин узла.
   2. Проверка комбинаций вершин на наличие связей образующих треугольник. Для того чтобы исключить дублирующие проверки 
      применил классический подход с двумя вложенными циклами. Первый цикл используется для выбора первой вершины i, а второй
      для выбора второй вершины j = i + 1. Таким образом исключаются повторяющиеся комбинации.

   Временная сложность алгоритма кубическая O(n^3), пространственная сложность - O(n) поскольку нужно хранить список найденных треугольников.
   
# Задание 2

   В целом решение повторяет подход из первой задачи с некоторыми доработками. Главное отличие: вместо подсчёта всех 
   треугольников проверяется только факт наличия хотя бы одного. В интерфейс класс добавлено публичное 
   свойство для получения общего размера дерева, чтобы понимать до каких пределов итерировать индексы. Также добавлен 
   индексатор, для доступа к вершине Vertex<T> при формировании итогового списка. Для проверки связи вершин используется 
   метод IsEdge. 
   
   Для проверки наличия связи используется тот же подход, что и при поиске треугольников связанных с узлом, но вместо 
   записи во множество используется булевый результат - как только нашли первое вхождение, то прерываем цикл и возвращаем true.
   Это даёт также небольшую оптимизацию по сравнению с поиском треугольников - не нужно искать все, достаточно обнаружить 
   хотя бы один и выйти.

   Временная сложность алгоритма кубическая O(n^3), пространственная сложность - O(n) поскольку нужно хранить список найденных узлов.
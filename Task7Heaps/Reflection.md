# Задача 3
   
   Решение рекурсивное. Идём по куче и на каждом шаге проверяем:
   
   - Если индекс вышел за пределы кучи, то возвращаем текущее наибольшее значение.
   - Если текущее значение меньше минимального, то возвращаем текущее найденное максимальное значение соответствующее диапазону. 
     Таким образом отсекаем проверку веток где уже точно не нужно смотреть т.к. глубже в ветку будут только меньшие значения.
   - Если же текущее значение находится в указанном диапазоне и больше текущего обнаруженного значения, то обновляем 
     текущее максимальное значение.
   - Рекурсивно ищем значения в левой и правой дочерних ветках.
   - Сравниваем полученные значения и возвращаем большее из них

   Такой алгоритм позволяет за O(n) временной сложности найти значение удовлетворяющее диапазону. Эффективность поиска та же 
   что и у массива, так что преимуществ по поиску перед массивом не имеет.
   
# Задача 5

   Решение рекурсивное. По аналогии с предыдущим заданием, но с изменением условий:
 
   - Если текущее значение меньше текущего минимального наиболее близкого к указанному, то возвращаем текущее наибольшее значение
     ниже минимального. Такие ветви проверять далее не нужно.
   - Если же текущее значение находится в указанном диапазоне и больше текущего обнаруженного значения, то обновляем 
     текущее обнаруженное максимальное значение.
   - Рекурсивно ищем значения в левой и правой дочерних ветках.

   Временная сложность также O(n). Такая структура данных позволяет быстро получать приоритетные значения, но поиск по критериям 
   не отличается от массива.

# Задача 6

   Добавив во внешний интерфейс класса свойство или метод, который предоставит информацию о текущем количестве элементов 
   в куче, можно решить задачу используя методы GetMax и Add. Реализация достаточно проста - в цикле извлекаем максимальное 
   значение через `GetMax` из второй кучи и добавляем его в первую через `Add` пока не заберём все значения из второй кучи. 

   Временная сложность такого алгоритма O(n log n) поскольку происходит просеивание каждого значения из второй кучи по первой.
   Пространственная сложность определяется только стековой памятью и зависит от высоты второй кучи - O(h).
   
# Задание 2

   Искал особенности балансировки четных двоичных деревьев. С точки зрения балансировки те же что и для АВЛ дерева - 
   высота не должна различаться более чем на 1 уровень. Также нашёл информацию о том, что балансировка четных деревьев 
   подразумевает разделение четного дерева на максимальное количество четных поддеревьев. Поскольку второе определение 
   уже реализовано в первой задаче решил что требуется именно первый вариант - классическая балансировка. 
   
   Для балансировки применил рекурсивный алгоритм in-order обхода дерева в глубину, для того чтобы собрать все значения 
   в список в уже отсортированном виде. Затем из середины списка берётся узел - он будет корнем. Далее от середины делим 
   список пополам и так рекурсивно выстраиваем поддеревья. Метод создаёт полную копию дерева не изменяя исходного. 
   
   Балансировка выполняется за O(n) временной сложности и O(n) пространственной.


# Задание 3

   Для обхода поддеревьев используем рекурсию. В качестве возвращаемого значения рекурсивного метода возвращается кортеж 
   из количества вершин и количества чётных поддеревьев. Обходим каждый дочерний узел и рекурсивно вызываем метод подсчёта 
   чётных поддеревьев, после обхода проверяем количество вершин и на какой мы сейчас вершине. Если количество вершин чётное
   и текущая вершина не корень, с которого начинался обход, то увеличиваем количество чётных поддеревьев на 1.
   
   Поиск выполняется за O(n) временной сложности и O(h) пространственной сложности, где h - максимальная глубина поддерева
   от текущего узла.
   

# Задача 3

    В целом алгоритм достаточно прост - идём по каждому узлу и меняем местами левую и правую ноды, при этом переставляя связанные поддеревья. Сначала для алгоритма выбрал горизонтальный обход дерева без использования рекурсии. Задействовал очередь - сперва добавил туда корень, а затем поочерёдно извлекая узлы и добавляя дочерние узлы обошёл всё дерево, при этом меняя дочерние узлы местами. Для сравнения реализовал рекурсивный обход в глубину. 

    Реализация обхода в глубину выглядит проще чем с обходом в ширину т.к. содержит минимум действий, в то время как реализация с обходом в ширину несколько сложнее и использует дополнительную структуру данных для промежуточного хранения узлов.

    Временные сложности алгоритмов одинаковые - O(n) т.к. для инвертирования нужно обойти все узлы дерева. Пространственные сложности отличаются - при обходе в ширину мы используем дополнительную память чтобы хранить дочерние узлы которые нам предстоит обойти, что в итоге даст сложность O(w) где w - ширина уровня. При обходе в глубину дополнительная память кучи не используется, однако расходуется стек и есть ограничения по высоте дерева. Сложность при обходе в глубину зависит от глубины и является O(h). 

    В данном случае обход в ширину позволяет обходить деревья любых размеров, задействуя при этом некоторое количество памяти из кучи, а обход в глубину не использует лишней памяти кучи, но ограничен по высоте дерева. В целом тут также доказываются общие рекомендации, что для неглубоких деревьев хорошо подойдёт обход в глубину, а для узких - обход в ширину. 

# Задача 4

    Реализация берёт за основу алгоритм обхода дерева в ширину. На каждом уровне вычисляется сумма значений, определяется нужно ли обновить максимальное значение, а также собираются узлы следующего уровня.
    
    В качестве оптимизации тут можно избавиться от Linq выражения которое делает дополнительную аллокацию и проход по массиву для вычисления суммы. Для этого нужно одновременно собирать узлы следующего уровня и вычислять текущую сумму уровня. Также можно преобразовать дерево в массив, чтобы был упорядоченный доступ к памяти - это позволит эффективнее использовать кэш процессора при обработке значений. Из более радикальных средств можно предположить использование векторизации (System.Numerics.Vector в .NET) чтобы за один такт процессора выполнялось больше опреаций суммирования, но эта оптимизация зависит от того поддерживает ли процессор такие операции. Алгоритмических путей улучшения придумать не смог, насколько понимаю в любом случае придётся обойти все узлы, что в любом случае даёт временную сложность O(n).

# Задача 5

    Исходя из того, что в префиксном массиве корень дерева находится на первом месте, а в инфиксном посередине можно находить левое и правое поддеревья получая значение из префиксного массива и определяя индекс такого значения в инфиксном массиве шаг за шагом находить поддеревья восстанавливая всё дерево. Для рекурсивного метода определил параметры начала и конца диапазона значений в поддереве и ссылки на сами массивы. Т.к. индекс определяю стандартным методом `IndexOf`, то индексы начала и конца нужны только чтобы понять когда нужно закончить рекурсивный обход. Логика следующая - проверяем пересечение индексов - если пересеклись, то дошли до конца - выходим. Затем получаем текущий узел, который будем добавлять в дерево. ищем индекс этого узла в инфиксном массиве для определения левого и правого поддеревьев. Удаляем из префиксного массива использованный узел. Рекурсивно для левого и правого поддеревьев вызываем метод поиска следующего узла со смещением индекса относительно текущего узла, а затем возвращаем полученную ноду.

    Временная сложность такого алгоритма O(n^2) т.к. нужно обойти все узлы и для каждого узла выполняется поиск индекса. Пространственная O(n) поскольку в дереве участвуют все полученные узлы. Также при обходе используется стековая память поэтому общую пространственную сложность можно выразить как O(n + h).